/// Generated by the Protocol Buffers 3.2.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.13
/// Source file "session.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct SessionRoot {
    public static let `default` = SessionRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}



//Enum type declaration start 

public enum SensorLocation:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
    case chest = 0
    case arm = 1
    case wrist = 2
    case hip = 3
    case ankle = 4
    public func toString() -> String {
        switch self {
        case .chest: return "Chest"
        case .arm: return "Arm"
        case .wrist: return "Wrist"
        case .hip: return "Hip"
        case .ankle: return "Ankle"
        }
    }
    public static func fromString(str:String) throws -> SensorLocation {
        switch str {
        case "Chest":    return .chest
        case "Arm":    return .arm
        case "Wrist":    return .wrist
        case "Hip":    return .hip
        case "Ankle":    return .ankle
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .chest: return ".chest"
        case .arm: return ".arm"
        case .wrist: return ".wrist"
        case .hip: return ".hip"
        case .ankle: return ".ankle"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:SensorLocation, rhs:SensorLocation) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 



//Enum type declaration start 

public enum SensorDataType:Int32, CustomDebugStringConvertible, CustomStringConvertible, Hashable {
    case acceleration = 0
    case rotation = 1
    case heartRate = 2
    public func toString() -> String {
        switch self {
        case .acceleration: return "Acceleration"
        case .rotation: return "Rotation"
        case .heartRate: return "HeartRate"
        }
    }
    public static func fromString(str:String) throws -> SensorDataType {
        switch str {
        case "Acceleration":    return .acceleration
        case "Rotation":    return .rotation
        case "HeartRate":    return .heartRate
        default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion String to Enum has failed.")
        }
    }
    public var debugDescription:String { return getDescription() }
    public var description:String { return getDescription() }
    private func getDescription() -> String { 
        switch self {
        case .acceleration: return ".acceleration"
        case .rotation: return ".rotation"
        case .heartRate: return ".heartRate"
        }
    }
    public var hashValue:Int {
        return self.rawValue.hashValue
    }
    public static func ==(lhs:SensorDataType, rhs:SensorDataType) -> Bool {
        return lhs.hashValue == rhs.hashValue
    }
}

//Enum type declaration end 

final public class Session : GeneratedMessage {

    public static func == (lhs: Session, rhs: Session) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
        fieldCheck = fieldCheck && (lhs.automaticLabels == rhs.automaticLabels)
        fieldCheck = fieldCheck && (lhs.userLabels == rhs.userLabels)
        fieldCheck = fieldCheck && (lhs.hasSensorData == rhs.hasSensorData) && (!lhs.hasSensorData || lhs.sensorData == rhs.sensorData)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var sessionId:String = ""
    public fileprivate(set) var hasSessionId:Bool = false

    public fileprivate(set) var automaticLabels:Array<Label>  = Array<Label>()
    public fileprivate(set) var userLabels:Array<Label>  = Array<Label>()
    public fileprivate(set) var sensorData:SensorData!
    public fileprivate(set) var hasSensorData:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSessionId {
            try codedOutputStream.writeString(fieldNumber: 1, value:sessionId)
        }
        for oneElementAutomaticLabels in automaticLabels {
              try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementAutomaticLabels)
        }
        for oneElementUserLabels in userLabels {
              try codedOutputStream.writeMessage(fieldNumber: 3, value:oneElementUserLabels)
        }
        if hasSensorData {
            try codedOutputStream.writeMessage(fieldNumber: 4, value:sensorData)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSessionId {
            serialize_size += sessionId.computeStringSize(fieldNumber: 1)
        }
        for oneElementAutomaticLabels in automaticLabels {
            serialize_size += oneElementAutomaticLabels.computeMessageSize(fieldNumber: 2)
        }
        for oneElementUserLabels in userLabels {
            serialize_size += oneElementUserLabels.computeMessageSize(fieldNumber: 3)
        }
        if hasSensorData {
            if let varSizesensorData = sensorData?.computeMessageSize(fieldNumber: 4) {
                serialize_size += varSizesensorData
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Session.Builder {
        return Session.classBuilder() as! Session.Builder
    }
    public func getBuilder() -> Session.Builder {
        return classBuilder() as! Session.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Session.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Session.Builder()
    }
    public func toBuilder() throws -> Session.Builder {
        return try Session.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Session) throws -> Session.Builder {
        return try Session.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasSessionId {
            jsonMap["sessionId"] = sessionId
        }
        if !automaticLabels.isEmpty {
            var jsonArrayAutomaticLabels:Array<Dictionary<String,Any>> = []
            for oneValueAutomaticLabels in automaticLabels {
                let ecodedMessageAutomaticLabels = try oneValueAutomaticLabels.encode()
                jsonArrayAutomaticLabels.append(ecodedMessageAutomaticLabels)
            }
            jsonMap["automaticLabels"] = jsonArrayAutomaticLabels
        }
        if !userLabels.isEmpty {
            var jsonArrayUserLabels:Array<Dictionary<String,Any>> = []
            for oneValueUserLabels in userLabels {
                let ecodedMessageUserLabels = try oneValueUserLabels.encode()
                jsonArrayUserLabels.append(ecodedMessageUserLabels)
            }
            jsonMap["userLabels"] = jsonArrayUserLabels
        }
        if hasSensorData {
            jsonMap["sensorData"] = try sensorData.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Session {
        return try Session.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Session {
        return try Session.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSessionId {
            output += "\(indent) sessionId: \(sessionId) \n"
        }
        var automaticLabelsElementIndex:Int = 0
        for oneElementAutomaticLabels in automaticLabels {
            output += "\(indent) automaticLabels[\(automaticLabelsElementIndex)] {\n"
            output += try oneElementAutomaticLabels.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            automaticLabelsElementIndex += 1
        }
        var userLabelsElementIndex:Int = 0
        for oneElementUserLabels in userLabels {
            output += "\(indent) userLabels[\(userLabelsElementIndex)] {\n"
            output += try oneElementUserLabels.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            userLabelsElementIndex += 1
        }
        if hasSensorData {
            output += "\(indent) sensorData {\n"
            if let outDescSensorData = sensorData {
                output += try outDescSensorData.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSessionId {
                hashCode = (hashCode &* 31) &+ sessionId.hashValue
            }
            for oneElementAutomaticLabels in automaticLabels {
                hashCode = (hashCode &* 31) &+ oneElementAutomaticLabels.hashValue
            }
            for oneElementUserLabels in userLabels {
                hashCode = (hashCode &* 31) &+ oneElementUserLabels.hashValue
            }
            if hasSensorData {
                if let hashValuesensorData = sensorData?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuesensorData
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Session"
    }
    override public func className() -> String {
        return "Session"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Session = Session()
        public func getMessage() -> Session {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var sessionId:String {
            get {
                return builderResult.sessionId
            }
            set (value) {
                builderResult.hasSessionId = true
                builderResult.sessionId = value
            }
        }
        public var hasSessionId:Bool {
            get {
                return builderResult.hasSessionId
            }
        }
        @discardableResult
        public func setSessionId(_ value:String) -> Session.Builder {
            self.sessionId = value
            return self
        }
        @discardableResult
        public func clearSessionId() -> Session.Builder{
            builderResult.hasSessionId = false
            builderResult.sessionId = ""
            return self
        }
        public var automaticLabels:Array<Label> {
            get {
                return builderResult.automaticLabels
            }
            set (value) {
                builderResult.automaticLabels = value
            }
        }
        @discardableResult
        public func setAutomaticLabels(_ value:Array<Label>) -> Session.Builder {
            self.automaticLabels = value
            return self
        }
        @discardableResult
        public func clearAutomaticLabels() -> Session.Builder {
            builderResult.automaticLabels.removeAll(keepingCapacity: false)
            return self
        }
        public var userLabels:Array<Label> {
            get {
                return builderResult.userLabels
            }
            set (value) {
                builderResult.userLabels = value
            }
        }
        @discardableResult
        public func setUserLabels(_ value:Array<Label>) -> Session.Builder {
            self.userLabels = value
            return self
        }
        @discardableResult
        public func clearUserLabels() -> Session.Builder {
            builderResult.userLabels.removeAll(keepingCapacity: false)
            return self
        }
        public var sensorData:SensorData! {
            get {
                if sensorDataBuilder_ != nil {
                    builderResult.sensorData = sensorDataBuilder_.getMessage()
                }
                return builderResult.sensorData
            }
            set (value) {
                builderResult.hasSensorData = true
                builderResult.sensorData = value
            }
        }
        public var hasSensorData:Bool {
            get {
                return builderResult.hasSensorData
            }
        }
        fileprivate var sensorDataBuilder_:SensorData.Builder! {
            didSet {
                builderResult.hasSensorData = true
            }
        }
        public func getSensorDataBuilder() -> SensorData.Builder {
            if sensorDataBuilder_ == nil {
                sensorDataBuilder_ = SensorData.Builder()
                builderResult.sensorData = sensorDataBuilder_.getMessage()
                if sensorData != nil {
                    try! sensorDataBuilder_.mergeFrom(other: sensorData)
                }
            }
            return sensorDataBuilder_
        }
        @discardableResult
        public func setSensorData(_ value:SensorData!) -> Session.Builder {
            self.sensorData = value
            return self
        }
        @discardableResult
        public func mergeSensorData(value:SensorData) throws -> Session.Builder {
            if builderResult.hasSensorData {
                builderResult.sensorData = try SensorData.builderWithPrototype(prototype:builderResult.sensorData).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.sensorData = value
            }
            builderResult.hasSensorData = true
            return self
        }
        @discardableResult
        public func clearSensorData() -> Session.Builder {
            sensorDataBuilder_ = nil
            builderResult.hasSensorData = false
            builderResult.sensorData = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Session.Builder {
            builderResult = Session()
            return self
        }
        override public func clone() throws -> Session.Builder {
            return try Session.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Session {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Session {
            let returnMe:Session = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Session) throws -> Session.Builder {
            if other == Session() {
                return self
            }
            if other.hasSessionId {
                sessionId = other.sessionId
            }
            if !other.automaticLabels.isEmpty  {
                 builderResult.automaticLabels += other.automaticLabels
            }
            if !other.userLabels.isEmpty  {
                 builderResult.userLabels += other.userLabels
            }
            if (other.hasSensorData) {
                try mergeSensorData(value: other.sensorData)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Session.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Session.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    sessionId = try codedInputStream.readString()

                case 18:
                    let subBuilder = Label.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    automaticLabels.append(subBuilder.buildPartial())

                case 26:
                    let subBuilder = Label.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    userLabels.append(subBuilder.buildPartial())

                case 34:
                    let subBuilder:SensorData.Builder = SensorData.Builder()
                    if hasSensorData {
                        try subBuilder.mergeFrom(other: sensorData)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    sensorData = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Session.Builder {
            let resultDecodedBuilder = Session.Builder()
            if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                resultDecodedBuilder.sessionId = jsonValueSessionId
            }
            if let jsonValueAutomaticLabels = jsonMap["automaticLabels"] as? Array<Dictionary<String,Any>> {
                var jsonArrayAutomaticLabels:Array<Label> = []
                for oneValueAutomaticLabels in jsonValueAutomaticLabels {
                    let messageFromStringAutomaticLabels = try Label.Builder.decodeToBuilder(jsonMap:oneValueAutomaticLabels).build()

                    jsonArrayAutomaticLabels.append(messageFromStringAutomaticLabels)
                }
                resultDecodedBuilder.automaticLabels = jsonArrayAutomaticLabels
            }
            if let jsonValueUserLabels = jsonMap["userLabels"] as? Array<Dictionary<String,Any>> {
                var jsonArrayUserLabels:Array<Label> = []
                for oneValueUserLabels in jsonValueUserLabels {
                    let messageFromStringUserLabels = try Label.Builder.decodeToBuilder(jsonMap:oneValueUserLabels).build()

                    jsonArrayUserLabels.append(messageFromStringUserLabels)
                }
                resultDecodedBuilder.userLabels = jsonArrayUserLabels
            }
            if let jsonValueSensorData = jsonMap["sensorData"] as? Dictionary<String,Any> {
                resultDecodedBuilder.sensorData = try SensorData.Builder.decodeToBuilder(jsonMap:jsonValueSensorData).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Session.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Session.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Label : GeneratedMessage {

    public static func == (lhs: Label, rhs: Label) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasStartTime == rhs.hasStartTime) && (!lhs.hasStartTime || lhs.startTime == rhs.startTime)
        fieldCheck = fieldCheck && (lhs.hasDuration == rhs.hasDuration) && (!lhs.hasDuration || lhs.duration == rhs.duration)
        fieldCheck = fieldCheck && (lhs.hasLabel == rhs.hasLabel) && (!lhs.hasLabel || lhs.label == rhs.label)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var startTime:Float = Float(0)
    public fileprivate(set) var hasStartTime:Bool = false

    public fileprivate(set) var duration:Float = Float(0)
    public fileprivate(set) var hasDuration:Bool = false

    public fileprivate(set) var label:String = ""
    public fileprivate(set) var hasLabel:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasStartTime {
            try codedOutputStream.writeFloat(fieldNumber: 1, value:startTime)
        }
        if hasDuration {
            try codedOutputStream.writeFloat(fieldNumber: 2, value:duration)
        }
        if hasLabel {
            try codedOutputStream.writeString(fieldNumber: 3, value:label)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasStartTime {
            serialize_size += startTime.computeFloatSize(fieldNumber: 1)
        }
        if hasDuration {
            serialize_size += duration.computeFloatSize(fieldNumber: 2)
        }
        if hasLabel {
            serialize_size += label.computeStringSize(fieldNumber: 3)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Label.Builder {
        return Label.classBuilder() as! Label.Builder
    }
    public func getBuilder() -> Label.Builder {
        return classBuilder() as! Label.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Label.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Label.Builder()
    }
    public func toBuilder() throws -> Label.Builder {
        return try Label.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Label) throws -> Label.Builder {
        return try Label.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasStartTime {
            jsonMap["startTime"] = Float(startTime)
        }
        if hasDuration {
            jsonMap["duration"] = Float(duration)
        }
        if hasLabel {
            jsonMap["label"] = label
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Label {
        return try Label.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Label {
        return try Label.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasStartTime {
            output += "\(indent) startTime: \(startTime) \n"
        }
        if hasDuration {
            output += "\(indent) duration: \(duration) \n"
        }
        if hasLabel {
            output += "\(indent) label: \(label) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasStartTime {
                hashCode = (hashCode &* 31) &+ startTime.hashValue
            }
            if hasDuration {
                hashCode = (hashCode &* 31) &+ duration.hashValue
            }
            if hasLabel {
                hashCode = (hashCode &* 31) &+ label.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Label"
    }
    override public func className() -> String {
        return "Label"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Label = Label()
        public func getMessage() -> Label {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var startTime:Float {
            get {
                return builderResult.startTime
            }
            set (value) {
                builderResult.hasStartTime = true
                builderResult.startTime = value
            }
        }
        public var hasStartTime:Bool {
            get {
                return builderResult.hasStartTime
            }
        }
        @discardableResult
        public func setStartTime(_ value:Float) -> Label.Builder {
            self.startTime = value
            return self
        }
        @discardableResult
        public func clearStartTime() -> Label.Builder{
            builderResult.hasStartTime = false
            builderResult.startTime = Float(0)
            return self
        }
        public var duration:Float {
            get {
                return builderResult.duration
            }
            set (value) {
                builderResult.hasDuration = true
                builderResult.duration = value
            }
        }
        public var hasDuration:Bool {
            get {
                return builderResult.hasDuration
            }
        }
        @discardableResult
        public func setDuration(_ value:Float) -> Label.Builder {
            self.duration = value
            return self
        }
        @discardableResult
        public func clearDuration() -> Label.Builder{
            builderResult.hasDuration = false
            builderResult.duration = Float(0)
            return self
        }
        public var label:String {
            get {
                return builderResult.label
            }
            set (value) {
                builderResult.hasLabel = true
                builderResult.label = value
            }
        }
        public var hasLabel:Bool {
            get {
                return builderResult.hasLabel
            }
        }
        @discardableResult
        public func setLabel(_ value:String) -> Label.Builder {
            self.label = value
            return self
        }
        @discardableResult
        public func clearLabel() -> Label.Builder{
            builderResult.hasLabel = false
            builderResult.label = ""
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Label.Builder {
            builderResult = Label()
            return self
        }
        override public func clone() throws -> Label.Builder {
            return try Label.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Label {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Label {
            let returnMe:Label = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Label) throws -> Label.Builder {
            if other == Label() {
                return self
            }
            if other.hasStartTime {
                startTime = other.startTime
            }
            if other.hasDuration {
                duration = other.duration
            }
            if other.hasLabel {
                label = other.label
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Label.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Label.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 13:
                    startTime = try codedInputStream.readFloat()

                case 21:
                    duration = try codedInputStream.readFloat()

                case 26:
                    label = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Label.Builder {
            let resultDecodedBuilder = Label.Builder()
            if let jsonValueStartTime = jsonMap["startTime"] as? Float {
                resultDecodedBuilder.startTime = Float(jsonValueStartTime)
            } else if let jsonValueStartTime = jsonMap["startTime"] as? String {
                resultDecodedBuilder.startTime = Float(jsonValueStartTime)!
            }
            if let jsonValueDuration = jsonMap["duration"] as? Float {
                resultDecodedBuilder.duration = Float(jsonValueDuration)
            } else if let jsonValueDuration = jsonMap["duration"] as? String {
                resultDecodedBuilder.duration = Float(jsonValueDuration)!
            }
            if let jsonValueLabel = jsonMap["label"] as? String {
                resultDecodedBuilder.label = jsonValueLabel
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Label.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Label.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class SensorData : GeneratedMessage {

    public static func == (lhs: SensorData, rhs: SensorData) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.values == rhs.values)
        fieldCheck = fieldCheck && (lhs.sensors == rhs.sensors)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var values:Array<Float> = Array<Float>()
    private var valuesMemoizedSerializedSize:Int32 = -1
    public fileprivate(set) var sensors:Array<Sensor>  = Array<Sensor>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if !values.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 10)
            try codedOutputStream.writeRawVarint32(value: valuesMemoizedSerializedSize)
            for oneValuevalues in values {
                try codedOutputStream.writeFloatNoTag(value: oneValuevalues)
            }
        }
        for oneElementSensors in sensors {
              try codedOutputStream.writeMessage(fieldNumber: 2, value:oneElementSensors)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        var dataSizeValues:Int32 = 0
        dataSizeValues = 4 * Int32(values.count)
        serialize_size += dataSizeValues
        if !values.isEmpty {
            serialize_size += 1
            serialize_size += dataSizeValues.computeInt32SizeNoTag()
        }
        valuesMemoizedSerializedSize = dataSizeValues
        for oneElementSensors in sensors {
            serialize_size += oneElementSensors.computeMessageSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> SensorData.Builder {
        return SensorData.classBuilder() as! SensorData.Builder
    }
    public func getBuilder() -> SensorData.Builder {
        return classBuilder() as! SensorData.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SensorData.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return SensorData.Builder()
    }
    public func toBuilder() throws -> SensorData.Builder {
        return try SensorData.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:SensorData) throws -> SensorData.Builder {
        return try SensorData.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if !values.isEmpty {
            var jsonArrayValues:Array<Float> = []
            for oneValueValues in values {
                jsonArrayValues.append(Float(oneValueValues))
            }
            jsonMap["values"] = jsonArrayValues
        }
        if !sensors.isEmpty {
            var jsonArraySensors:Array<Dictionary<String,Any>> = []
            for oneValueSensors in sensors {
                let ecodedMessageSensors = try oneValueSensors.encode()
                jsonArraySensors.append(ecodedMessageSensors)
            }
            jsonMap["sensors"] = jsonArraySensors
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> SensorData {
        return try SensorData.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> SensorData {
        return try SensorData.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        var valuesElementIndex:Int = 0
        for oneValueValues in values  {
            output += "\(indent) values[\(valuesElementIndex)]: \(oneValueValues)\n"
            valuesElementIndex += 1
        }
        var sensorsElementIndex:Int = 0
        for oneElementSensors in sensors {
            output += "\(indent) sensors[\(sensorsElementIndex)] {\n"
            output += try oneElementSensors.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            sensorsElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            for oneValueValues in values {
                hashCode = (hashCode &* 31) &+ oneValueValues.hashValue
            }
            for oneElementSensors in sensors {
                hashCode = (hashCode &* 31) &+ oneElementSensors.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "SensorData"
    }
    override public func className() -> String {
        return "SensorData"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:SensorData = SensorData()
        public func getMessage() -> SensorData {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var values:Array<Float> {
            get {
                return builderResult.values
            }
            set (array) {
                builderResult.values = array
            }
        }
        @discardableResult
        public func setValues(_ value:Array<Float>) -> SensorData.Builder {
            self.values = value
            return self
        }
        @discardableResult
        public func clearValues() -> SensorData.Builder {
            builderResult.values.removeAll(keepingCapacity: false)
            return self
        }
        public var sensors:Array<Sensor> {
            get {
                return builderResult.sensors
            }
            set (value) {
                builderResult.sensors = value
            }
        }
        @discardableResult
        public func setSensors(_ value:Array<Sensor>) -> SensorData.Builder {
            self.sensors = value
            return self
        }
        @discardableResult
        public func clearSensors() -> SensorData.Builder {
            builderResult.sensors.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> SensorData.Builder {
            builderResult = SensorData()
            return self
        }
        override public func clone() throws -> SensorData.Builder {
            return try SensorData.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> SensorData {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> SensorData {
            let returnMe:SensorData = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:SensorData) throws -> SensorData.Builder {
            if other == SensorData() {
                return self
            }
            if !other.values.isEmpty {
                builderResult.values += other.values
            }
            if !other.sensors.isEmpty  {
                 builderResult.sensors += other.sensors
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> SensorData.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SensorData.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let length = Int(try codedInputStream.readRawVarint32())
                    let limit = try codedInputStream.pushLimit(byteLimit: length)
                    while (codedInputStream.bytesUntilLimit() > 0) {
                        builderResult.values.append(try codedInputStream.readFloat())
                    }
                    codedInputStream.popLimit(oldLimit: limit)

                case 18:
                    let subBuilder = Sensor.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    sensors.append(subBuilder.buildPartial())

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> SensorData.Builder {
            let resultDecodedBuilder = SensorData.Builder()
            if let jsonValueValues = jsonMap["values"] as? Array<Float> {
                var jsonArrayValues:Array<Float> = []
                for oneValueValues in jsonValueValues {
                    jsonArrayValues.append(Float(oneValueValues))
                }
                resultDecodedBuilder.values = jsonArrayValues
            }
            if let jsonValueSensors = jsonMap["sensors"] as? Array<Dictionary<String,Any>> {
                var jsonArraySensors:Array<Sensor> = []
                for oneValueSensors in jsonValueSensors {
                    let messageFromStringSensors = try Sensor.Builder.decodeToBuilder(jsonMap:oneValueSensors).build()

                    jsonArraySensors.append(messageFromStringSensors)
                }
                resultDecodedBuilder.sensors = jsonArraySensors
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> SensorData.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try SensorData.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Sensor : GeneratedMessage {

    public static func == (lhs: Sensor, rhs: Sensor) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasLocation == rhs.hasLocation) && (!lhs.hasLocation || lhs.location == rhs.location)
        fieldCheck = fieldCheck && (lhs.dataTypes == rhs.dataTypes)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var location:SensorLocation = SensorLocation.chest
    public fileprivate(set) var hasLocation:Bool = false
    private var dataTypesMemoizedSerializedSize:Int32 = 0
    public fileprivate(set) var dataTypes:Array<SensorDataType> = Array<SensorDataType>()
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasLocation {
            try codedOutputStream.writeEnum(fieldNumber: 1, value:location.rawValue)
        }
        if !dataTypes.isEmpty {
            try codedOutputStream.writeRawVarint32(value: 18)
            try codedOutputStream.writeRawVarint32(value: dataTypesMemoizedSerializedSize)
        }
        for oneValueOfdataTypes in dataTypes {
              try codedOutputStream.writeEnumNoTag(value: oneValueOfdataTypes.rawValue)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if (hasLocation) {
            serialize_size += location.rawValue.computeEnumSize(fieldNumber: 1)
        }
        var dataSizedataTypes:Int32 = 0
        for oneValueOfdataTypes in dataTypes {
            dataSizedataTypes += oneValueOfdataTypes.rawValue.computeEnumSizeNoTag()
        }
        serialize_size += dataSizedataTypes
        if !dataTypes.isEmpty {
            serialize_size += 1
            serialize_size += dataSizedataTypes.computeRawVarint32Size()
        }
        dataTypesMemoizedSerializedSize = dataSizedataTypes
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Sensor.Builder {
        return Sensor.classBuilder() as! Sensor.Builder
    }
    public func getBuilder() -> Sensor.Builder {
        return classBuilder() as! Sensor.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Sensor.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Sensor.Builder()
    }
    public func toBuilder() throws -> Sensor.Builder {
        return try Sensor.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Sensor) throws -> Sensor.Builder {
        return try Sensor.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasLocation {
            jsonMap["location"] = location.toString()
        }
        if !dataTypes.isEmpty {
            var jsonArrayDataTypes:Array<String> = []
            for oneValueDataTypes in dataTypes {
                jsonArrayDataTypes.append(oneValueDataTypes.toString())
            }
            jsonMap["dataTypes"] = jsonArrayDataTypes
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Sensor {
        return try Sensor.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Sensor {
        return try Sensor.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if (hasLocation) {
            output += "\(indent) location: \(location.description)\n"
        }
        var dataTypesElementIndex:Int = 0
        for oneValueOfdataTypes in dataTypes {
            output += "\(indent) dataTypes[\(dataTypesElementIndex)]: \(oneValueOfdataTypes.description)\n"
            dataTypesElementIndex += 1
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasLocation {
                 hashCode = (hashCode &* 31) &+ location.hashValue
            }
            for oneValueOfdataTypes in dataTypes {
                hashCode = (hashCode &* 31) &+ oneValueOfdataTypes.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Sensor"
    }
    override public func className() -> String {
        return "Sensor"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Sensor = Sensor()
        public func getMessage() -> Sensor {
            return builderResult
        }

        required override public init () {
            super.init()
        }
            public var location:SensorLocation {
                get {
                    return builderResult.location
                }
                set (value) {
                    builderResult.hasLocation = true
                    builderResult.location = value
                }
            }
            public var hasLocation:Bool{
                get {
                    return builderResult.hasLocation
                }
            }
        @discardableResult
            public func setLocation(_ value:SensorLocation) -> Sensor.Builder {
              self.location = value
              return self
            }
        @discardableResult
            public func clearLocation() -> Sensor.Builder {
               builderResult.hasLocation = false
               builderResult.location = .chest
               return self
            }
        public var dataTypes:Array<SensorDataType> {
            get {
                return builderResult.dataTypes
            }
            set (value) {
                builderResult.dataTypes = value
            }
        }
        @discardableResult
        public func setDataTypes(_ value:Array<SensorDataType>) -> Sensor.Builder {
            self.dataTypes = value
            return self
        }
        @discardableResult
        public func clearDataTypes() -> Sensor.Builder {
            builderResult.dataTypes.removeAll(keepingCapacity: false)
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Sensor.Builder {
            builderResult = Sensor()
            return self
        }
        override public func clone() throws -> Sensor.Builder {
            return try Sensor.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Sensor {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Sensor {
            let returnMe:Sensor = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Sensor) throws -> Sensor.Builder {
            if other == Sensor() {
                return self
            }
            if other.hasLocation {
                location = other.location
            }
            if !other.dataTypes.isEmpty {
                 builderResult.dataTypes += other.dataTypes
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Sensor.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Sensor.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    let valueIntlocation = try codedInputStream.readEnum()
                    if let enumslocation = SensorLocation(rawValue:valueIntlocation){
                        location = enumslocation
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 1, value:Int64(valueIntlocation))
                    }

                case 18:
                    let length = Int(try codedInputStream.readRawVarint32())
                    let oldLimit = try codedInputStream.pushLimit(byteLimit: length)
                    while codedInputStream.bytesUntilLimit() > 0 {
                    let valueIntdataTypes = try codedInputStream.readEnum()
                    if let enumsdataTypes = SensorDataType(rawValue:valueIntdataTypes) {
                        builderResult.dataTypes.append(enumsdataTypes)
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 2, value:Int64(valueIntdataTypes))
                    }
                    }
                    codedInputStream.popLimit(oldLimit: oldLimit)

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Sensor.Builder {
            let resultDecodedBuilder = Sensor.Builder()
            if let jsonValueLocation = jsonMap["location"] as? String {
                resultDecodedBuilder.location = try SensorLocation.fromString(str: jsonValueLocation)
            }
            if let jsonValueDataTypes = jsonMap["dataTypes"] as? Array<String> {
                var jsonArrayDataTypes:Array<SensorDataType> = []
                for oneValueDataTypes in jsonValueDataTypes {
                    let enumFromStringDataTypes = try SensorDataType.fromString(str: oneValueDataTypes)
                    jsonArrayDataTypes.append(enumFromStringDataTypes)
                }
                resultDecodedBuilder.dataTypes = jsonArrayDataTypes
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Sensor.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Sensor.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Session: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Session> {
        var mergedArray = Array<Session>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Session? {
        return try Session.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Session {
        return try Session.Builder().mergeFrom(data: data, extensionRegistry:SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Session {
        return try Session.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Session {
        return try Session.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Session {
        return try Session.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Session {
        return try Session.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Session {
        return try Session.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sessionId": return self.sessionId
        case "automaticLabels": return self.automaticLabels
        case "userLabels": return self.userLabels
        case "sensorData": return self.sensorData
        default: return nil
        }
    }
}
extension Session.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sessionId": return self.sessionId
            case "automaticLabels": return self.automaticLabels
            case "userLabels": return self.userLabels
            case "sensorData": return self.sensorData
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "automaticLabels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Label> else {
                    return
                }
                self.automaticLabels = newSubscriptValue
            case "userLabels":
                guard let newSubscriptValue = newSubscriptValue as? Array<Label> else {
                    return
                }
                self.userLabels = newSubscriptValue
            case "sensorData":
                guard let newSubscriptValue = newSubscriptValue as? SensorData else {
                    return
                }
                self.sensorData = newSubscriptValue
            default: return
            }
        }
    }
}
extension Label: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Label> {
        var mergedArray = Array<Label>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Label? {
        return try Label.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Label {
        return try Label.Builder().mergeFrom(data: data, extensionRegistry:SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Label {
        return try Label.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Label {
        return try Label.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Label {
        return try Label.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Label {
        return try Label.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Label {
        return try Label.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "startTime": return self.startTime
        case "duration": return self.duration
        case "label": return self.label
        default: return nil
        }
    }
}
extension Label.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "startTime": return self.startTime
            case "duration": return self.duration
            case "label": return self.label
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "startTime":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.startTime = newSubscriptValue
            case "duration":
                guard let newSubscriptValue = newSubscriptValue as? Float else {
                    return
                }
                self.duration = newSubscriptValue
            case "label":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.label = newSubscriptValue
            default: return
            }
        }
    }
}
extension SensorData: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<SensorData> {
        var mergedArray = Array<SensorData>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> SensorData? {
        return try SensorData.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> SensorData {
        return try SensorData.Builder().mergeFrom(data: data, extensionRegistry:SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> SensorData {
        return try SensorData.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> SensorData {
        return try SensorData.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> SensorData {
        return try SensorData.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> SensorData {
        return try SensorData.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> SensorData {
        return try SensorData.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "values": return self.values
        case "sensors": return self.sensors
        default: return nil
        }
    }
}
extension SensorData.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "values": return self.values
            case "sensors": return self.sensors
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "values":
                guard let newSubscriptValue = newSubscriptValue as? Array<Float> else {
                    return
                }
                self.values = newSubscriptValue
            case "sensors":
                guard let newSubscriptValue = newSubscriptValue as? Array<Sensor> else {
                    return
                }
                self.sensors = newSubscriptValue
            default: return
            }
        }
    }
}
extension Sensor: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Sensor> {
        var mergedArray = Array<Sensor>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Sensor? {
        return try Sensor.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Sensor {
        return try Sensor.Builder().mergeFrom(data: data, extensionRegistry:SessionRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Sensor {
        return try Sensor.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Sensor {
        return try Sensor.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Sensor {
        return try Sensor.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Sensor {
        return try Sensor.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Sensor {
        return try Sensor.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "location": return self.location
        case "dataTypes": return self.dataTypes
        default: return nil
        }
    }
}
extension Sensor.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "location": return self.location
            case "dataTypes": return self.dataTypes
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "location":
                guard let newSubscriptValue = newSubscriptValue as? SensorLocation else {
                    return
                }
                self.location = newSubscriptValue
            case "dataTypes":
                guard let newSubscriptValue = newSubscriptValue as? Array<SensorDataType> else {
                    return
                }
                self.dataTypes = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
